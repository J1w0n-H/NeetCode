# 코딩 기억노트 📚

> 알고리즘 문제 풀이와 코딩에서 자주 잊기 쉬운 내용들을 정리한 노트

---

## 🚨 자주 하는 실수들

### 1. **클래스 변수 vs 인스턴스 변수**
```python
# ❌ 잘못된 방법 - 클래스 변수 사용
class Solution:
    size = []  # 모든 인스턴스가 공유

# ✅ 올바른 방법 - 인스턴스 변수 사용
class Solution:
    def __init__(self):
        self.size = []  # 각 인스턴스마다 독립적
```

**문제점**: 클래스 변수는 모든 인스턴스가 공유하여 데이터 오염 발생

---

### 2. **문자열 연결 vs 리스트 조인**
```python
# ❌ 비효율적 - 매번 새로운 문자열 객체 생성
res = ""
for s in strs:
    res += s  # O(n²) 시간 복잡도

# ✅ 효율적 - 리스트에 모아서 한 번에 조인
res = []
for s in strs:
    res.append(s)
return "".join(res)  # O(n) 시간 복잡도
```

---

### 3. **인덱스 vs 값 순회**
```python
# ❌ 인덱스가 필요한 경우가 아니라면
for i in range(len(s)):
    print(s[i])

# ✅ 값만 필요한 경우
for char in s:
    print(char)

# ✅ 인덱스와 값 모두 필요한 경우
for i, char in enumerate(s):
    print(i, char)
```

---

### 4. **리스트 복사 vs 참조**
```python
# ❌ 참조 복사 (같은 객체)
list2 = list1

# ✅ 얕은 복사 (새로운 리스트 객체)
list2 = list1.copy()
list2 = list1[:]
list2 = list(list1)

# ✅ 깊은 복사 (중첩된 객체까지 복사)
import copy
list2 = copy.deepcopy(list1)
```

---

## 🔧 자주 사용하는 패턴들

### 1. **해시맵 기본값 처리**
```python
# ❌ 키 존재 여부 확인 후 처리
if key in count:
    count[key] += 1
else:
    count[key] = 1

# ✅ get() 메서드 사용
count[key] = count.get(key, 0) + 1

# ✅ defaultdict 사용
from collections import defaultdict
count = defaultdict(int)
count[key] += 1  # 자동으로 0으로 초기화
```

---

### 2. **빈도수 계산**
```python
# ❌ 수동으로 계산
count = {}
for num in nums:
    if num in count:
        count[num] += 1
    else:
        count[num] = 1

# ✅ Counter 사용
from collections import Counter
count = Counter(nums)
```

---

### 3. **문자열 파싱 패턴**
```python
# 길이를 먼저 읽고, 그 다음에 문자열 추출
def parse_length_string(s, i):
    j = i
    while s[j] != '#':
        j += 1
    length = int(s[i:j])
    i = j + 1
    j = i + length
    return s[i:j], j
```

---

### 4. **투 포인터 패턴**
```python
# 정렬된 배열에서 두 수의 합 찾기
def two_sum_sorted(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        curr_sum = nums[left] + nums[right]
        if curr_sum == target:
            return [left, right]
        elif curr_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

### 5. **Prefix Sum 패턴**
```python
# 기본 prefix sum (합계)
prefix = [0] * n
prefix[0] = nums[0]
for i in range(1, n):
    prefix[i] = prefix[i-1] + nums[i]

# Product prefix sum (곱)
prefix = [1] * n
prefix[0] = nums[0]
for i in range(1, n):
    prefix[i] = prefix[i-1] * nums[i]

# 구간 합 계산
def range_sum(prefix, left, right):
    if left == 0:
        return prefix[right]
    return prefix[right] - prefix[left-1]
```

### 6. **Hash Set 활용 패턴**
```python
# 연속 수열의 시작점 찾기
numSet = set(nums)
for num in numSet:
    if (num - 1) not in numSet:  # 시작점인지 확인
        length = 1
        while (num + length) in numSet:
            length += 1
        longest = max(longest, length)

# 중복 제거 및 빠른 조회
unique_nums = set(nums)  # 중복 자동 제거
if target in unique_nums:  # O(1) 조회
    # 처리 로직
```

---

## 📊 시간/공간 복잡도 기억하기

### **자주 나오는 복잡도들**
```python
# O(1) - 상수 시간
dict.get(), set.add(), list.append()

# O(log n) - 로그 시간
이진 탐색, 힙 연산

# O(n) - 선형 시간
리스트 순회, 해시맵 조회

# O(n log n) - 정렬 시간
sort(), sorted()

# O(n²) - 제곱 시간
중첩 루프, 버블 정렬, 선택 정렬

# O(2ⁿ) - 지수 시간
재귀 피보나치
```

---

## 🎯 알고리즘 설계 원칙

### 1. **단순성 우선**
- 복잡한 로직보다는 직관적인 접근 방식 선택
- 한 번에 여러 가지를 하려 하지 말기

### 2. **효율성 고려**
- 불필요한 중첩 루프 피하기
- 메모리 사용량 최소화

### 3. **명확성 유지**
- 각 단계의 목적이 명확해야 함
- 변수명은 의미있게 짓기

---

## 🔍 디버깅 팁

### 1. **print 문 사용법**
```python
# ❌ 프로덕션 코드에 남겨두기
print("DEBUG:", value)

# ✅ 개발 완료 후 제거
# 로깅 시스템 사용 고려
import logging
logging.debug(f"DEBUG: {value}")
```

### 2. **테스트 케이스 작성**
```python
def test_solution():
    # 일반적인 경우
    assert solution.encode(["Hello", "World"]) == "5#Hello5#World"
    
    # 경계 조건
    assert solution.encode([""]) == "0#"
    assert solution.encode([]) == ""
    
    # 특수 문자 포함
    assert solution.encode(["Hello#World"]) == "11#Hello#World"
```

---

## 📝 자주 잊기 쉬운 문법

### 1. **리스트 컴프리헨션**
```python
# 기본 형태
squares = [x**2 for x in range(10)]

# 조건 포함
even_squares = [x**2 for x in range(10) if x % 2 == 0]

# 중첩
matrix = [[i+j for j in range(3)] for i in range(3)]
```

### 2. **람다 함수**
```python
# 정렬 시 키 함수로 사용
nums = [(1, 'a'), (3, 'c'), (2, 'b')]
nums.sort(key=lambda x: x[1])  # 두 번째 요소로 정렬

# map과 함께 사용
squares = list(map(lambda x: x**2, [1, 2, 3, 4]))
```

### 3. **zip과 enumerate**
```python
# 두 리스트를 동시에 순회
for key, value in zip(keys, values):
    print(f"{key}: {value}")

# 인덱스와 값 동시에
for i, value in enumerate(values):
    print(f"Index {i}: {value}")
```

---

## 🚀 최적화 기법

### 1. **메모리 최적화**
```python
# ❌ 불필요한 중간 배열
sizes = []
for s in strs:
    sizes.append(len(s))
for sz in sizes:
    # 처리

# ✅ 직접 처리
for s in strs:
    length = len(s)
    # 처리
```

### 2. **구분자 설계**
```python
# ❌ 복잡한 구분자
res += str(sz) + ','  # 길이 + 쉼표
res += '#'            # 별도 구분자

# ✅ 단순한 구분자
res += str(len(s)) + "#" + s  # 길이 + # + 문자열
```

---

## 📚 문제 유형별 접근법

### **해시맵/해시셋 문제**
1. **중복 확인**: `set()` 사용
2. **빈도수 계산**: `Counter` 사용
3. **두 수의 합**: `target - num`이 해시맵에 있는지 확인

### **정렬 문제**
1. **안정 정렬**: `sort()` vs `sorted()`
2. **커스텀 정렬**: `key` 함수 사용
3. **부분 정렬**: `heapq` 사용

### **문자열 문제**
1. **구분자 설계**: 단순하게
2. **파싱**: 인덱스 관리 주의
3. **특수 문자**: 이스케이핑 고려

### **Array/Prefix Sum 문제**
1. **누적 계산**: prefix sum 활용
2. **공간 최적화**: 출력 배열을 임시 저장소로 활용
3. **방향성**: 왼쪽→오른쪽, 오른쪽→왼쪽 순회 조합
4. **0 처리**: 곱셈에서 0은 특별한 경우로 처리

### **Hash Set/Map 문제**
1. **빠른 조회**: O(1) 시간으로 요소 존재 여부 확인
2. **중복 제거**: set을 사용하여 자동으로 중복 제거
3. **시작점 찾기**: 연속 수열의 시작점만 확인하여 중복 계산 피하기
4. **경계 조건**: 빈 배열, 단일 요소 등 예외 상황 고려

---

## 🔄 지속 업데이트

이 노트는 새로운 문제를 풀 때마다 계속 업데이트됩니다.

**마지막 업데이트**: Longest Consecutive Sequence 문제 풀이 후

**추가된 내용**: 
- Prefix Sum 패턴
- Array 문제 접근법
- 공간 복잡도 최적화 기법
- Hash Set 활용 패턴
- Hash Set/Map 문제 접근법

**다음 업데이트 예정**: 새로운 알고리즘 패턴이나 문법 발견 시

---

*"코딩은 반복 학습이다. 한 번 배운 것도 잊기 쉽다. 이 노트를 통해 꾸준히 복습하자!"* 🚀
